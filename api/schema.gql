# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input AttachedDocumentInput {
  id: String
  type: String!
}

input BooleanFilter {
  equal: Boolean
}

type ContentScopeWithLabel {
  label: JSONObject!
  scope: JSONObject!
}

type CopyFilesResponse {
  mappedFiles: [MappedFile!]!
}

input CreateDamFolderInput {
  isInboxFromOtherScope: Boolean! = false
  name: String!
  parentId: ID
}

type CurrentUser {
  allowedContentScopes: [ContentScopeWithLabel!]!
  authenticatedUser: UserPermissionsUser
  email: String!
  id: String!
  impersonated: Boolean
  name: String!
  permissions: [CurrentUserPermission!]!
  permissionsForScope(scope: JSONObject!): [String!]!
}

type CurrentUserPermission {
  contentScopes: [JSONObject!]!
  permission: Permission!
}

type DamFile {
  altText: String
  alternativesForThisFile: [DamMediaAlternative!]!
  archived: Boolean!
  contentHash: String!
  createdAt: DateTime!
  damPath: String!
  dependents(filter: DependentFilter, forceRefresh: Boolean! = false, limit: Int! = 25, offset: Int! = 0): PaginatedDependencies!
  duplicates: [DamFile!]!
  fileUrl: String!
  folder: DamFolder
  id: ID!
  image: DamFileImage
  importSourceId: String
  importSourceType: String
  license: DamFileLicense
  mimetype: String!
  name: String!
  size: Int!
  thisFileIsAlternativeFor: [DamMediaAlternative!]!
  title: String
  updatedAt: DateTime!
}

type DamFileImage {
  cropArea: ImageCropArea!
  dominantColor: String
  exif: JSONObject
  height: Int!
  id: ID!
  url(height: Int!, width: Int!): String
  width: Int!
}

type DamFileLicense {
  author: String
  details: String
  durationFrom: DateTime
  durationTo: DateTime

  """The expirationDate is the durationTo + 1 day"""
  expirationDate: DateTime
  expiresWithinThirtyDays: Boolean!
  hasExpired: Boolean!
  isNotValidYet: Boolean!
  isValid: Boolean!
  type: LicenseType
}

type DamFolder {
  archived: Boolean!
  createdAt: DateTime!
  id: ID!
  isInboxFromOtherScope: Boolean!
  mpath: [ID!]!
  name: String!
  numberOfChildFolders: Int!
  numberOfFiles: Int!
  parent: DamFolder
  parents: [DamFolder!]!
  updatedAt: DateTime!
}

union DamItem = DamFile | DamFolder

input DamItemFilterInput {
  mimetypes: [String!]
  searchText: String
}

enum DamItemType {
  File
  Folder
}

type DamMediaAlternative {
  alternative: DamFile!
  for: DamFile!
  id: ID!
  language: String!
  type: DamMediaAlternativeType!
}

input DamMediaAlternativeInput {
  language: String!
  type: DamMediaAlternativeType!
}

input DamMediaAlternativeSort {
  direction: SortDirection! = ASC
  field: DamMediaAlternativeSortField!
}

enum DamMediaAlternativeSortField {
  alternative
  for
  id
  language
  type
}

enum DamMediaAlternativeType {
  captions
}

input DamMediaAlternativeUpdateInput {
  alternative: ID
  for: ID
  language: String
  type: DamMediaAlternativeType
}

input DamScopeInput {
  thisScopeHasNoFields____: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equal: DateTime
  greaterThan: DateTime
  greaterThanEqual: DateTime
  isEmpty: Boolean
  isNotEmpty: Boolean
  lowerThan: DateTime
  lowerThanEqual: DateTime
  notEqual: DateTime
}

type Dependency {
  jsonPath: String!
  name: String
  rootColumnName: String!
  rootGraphqlObjectType: String!
  rootId: String!
  secondaryInformation: String
  targetGraphqlObjectType: String!
  targetId: String!
  visible: Boolean!
}

input DependencyFilter {
  rootColumnName: String
  targetGraphqlObjectType: String
  targetId: String
}

input DependentFilter {
  rootColumnName: String
  rootGraphqlObjectType: String
  rootId: String
}

interface DocumentInterface {
  id: ID!
  updatedAt: DateTime!
}

type EntityInfo {
  name: String!
  secondaryInformation: String
}

input FileFilterInput {
  mimetypes: [String!]
  searchText: String
}

input FilenameInput {
  folderId: ID
  name: String!
}

type FilenameResponse {
  folderId: ID
  isOccupied: Boolean!
  name: String!
}

enum FocalPoint {
  CENTER
  NORTHEAST
  NORTHWEST
  SMART
  SOUTHEAST
  SOUTHWEST
}

input FolderFilterInput {
  searchText: String
}

type Footer implements DocumentInterface {
  content: FooterContentBlockData!
  createdAt: DateTime!
  id: ID!
  scope: FooterScope!
  updatedAt: DateTime!
}

"""FooterContent root block data"""
scalar FooterContentBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""FooterContent root block input"""
scalar FooterContentBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input FooterInput {
  content: FooterContentBlockInput!
}

type FooterScope {
  domain: String!
  language: String!
}

input FooterScopeInput {
  domain: String!
  language: String!
}

type ImageCropArea {
  focalPoint: FocalPoint!
  height: Float
  width: Float
  x: Float
  y: Float
}

input ImageCropAreaInput {
  focalPoint: FocalPoint!
  height: Float
  width: Float
  x: Float
  y: Float
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input LicenseInput {
  author: String
  details: String
  durationFrom: DateTime
  durationTo: DateTime
  type: LicenseType
}

enum LicenseType {
  RIGHTS_MANAGED
  ROYALTY_FREE
}

type Link implements DocumentInterface {
  content: LinkBlockData!
  createdAt: DateTime!
  id: ID!
  pageTreeNode: PageTreeNode
  updatedAt: DateTime!
}

"""Link root block data"""
scalar LinkBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""Link root block input"""
scalar LinkBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input LinkInput {
  content: LinkBlockInput!
}

type MappedFile {
  copy: DamFile!
  rootFile: DamFile!
}

input MovePageTreeNodesByNeighbourInput {
  afterId: String
  beforeId: String
  parentId: String
}

input MovePageTreeNodesByPosInput {
  parentId: String
  pos: Int!
}

type Mutation {
  archiveDamFile(id: ID!): DamFile!
  archiveDamFiles(ids: [ID!]!): [DamFile!]!
  copyFilesToScope(fileIds: [ID!]!, inboxFolderId: ID!): CopyFilesResponse!
  createDamFolder(input: CreateDamFolderInput!, scope: DamScopeInput! = {}): DamFolder!
  createDamMediaAlternative(alternative: ID!, for: ID!, input: DamMediaAlternativeInput!): DamMediaAlternative!
  createPageTreeNode(category: String!, input: PageTreeNodeCreateInput!, scope: PageTreeNodeScopeInput!): PageTreeNode!
  createRedirect(input: RedirectInput!, scope: RedirectScopeInput!): Redirect!
  currentUserSignOut: String!
  deleteDamFile(id: ID!): Boolean!
  deleteDamFolder(id: ID!): Boolean!
  deleteDamMediaAlternative(id: ID!): Boolean!
  deletePageTreeNode(id: ID!): Boolean!
  deleteRedirect(id: ID!): Boolean!
  importDamFileByDownload(input: UpdateDamFileInput!, scope: DamScopeInput! = {}, url: String!): DamFile!
  moveDamFiles(fileIds: [ID!]!, targetFolderId: ID): [DamFile!]!
  moveDamFolders(folderIds: [ID!]!, scope: DamScopeInput! = {}, targetFolderId: ID): [DamFolder!]!
  movePageTreeNodesByNeighbour(ids: [ID!]!, input: MovePageTreeNodesByNeighbourInput!): [PageTreeNode!]!
  movePageTreeNodesByPos(ids: [ID!]!, input: MovePageTreeNodesByPosInput!): [PageTreeNode!]!
  restoreDamFile(id: ID!): DamFile!
  restoreDamFiles(ids: [ID!]!): [DamFile!]!
  saveFooter(input: FooterInput!, scope: FooterScopeInput!): Footer!
  saveLink(attachedPageTreeNodeId: ID, id: ID!, input: LinkInput!, lastUpdatedAt: DateTime): Link!
  savePage(attachedPageTreeNodeId: ID, input: PageInput!, lastUpdatedAt: DateTime, pageId: ID!): Page!
  updateDamFile(id: ID!, input: UpdateDamFileInput!): DamFile!
  updateDamFolder(id: ID!, input: UpdateDamFolderInput!): DamFolder!
  updateDamMediaAlternative(id: ID!, input: DamMediaAlternativeUpdateInput!): DamMediaAlternative!
  updatePageTreeNode(id: ID!, input: PageTreeNodeUpdateInput!): PageTreeNode!
  updatePageTreeNodeCategory(category: String!, id: ID!): PageTreeNode!
  updatePageTreeNodeSlug(id: ID!, slug: String!): PageTreeNode!
  updatePageTreeNodeVisibility(id: ID!, input: PageTreeNodeUpdateVisibilityInput!): PageTreeNode!
  updateRedirect(id: ID!, input: RedirectInput!, lastUpdatedAt: DateTime): Redirect!
  updateRedirectActiveness(id: ID!, input: RedirectUpdateActivenessInput!): Redirect!
  userPermissionsCreatePermission(input: UserPermissionInput!, userId: String!): UserPermission!
  userPermissionsDeletePermission(id: ID!): Boolean!
  userPermissionsUpdateContentScopes(input: UserContentScopesInput!, userId: String!): Boolean!
  userPermissionsUpdateOverrideContentScopes(input: UserPermissionOverrideContentScopesInput!): UserPermission!
  userPermissionsUpdatePermission(id: String!, input: UserPermissionInput!): UserPermission!
}

type Page implements DocumentInterface {
  content: PageContentBlockData!
  createdAt: DateTime!
  id: ID!
  pageTreeNode: PageTreeNode
  seo: SeoBlockData!
  stage: StageBlockData!
  updatedAt: DateTime!
}

"""PageContent root block data"""
scalar PageContentBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""PageContent root block input"""
scalar PageContentBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

union PageContentUnion = Link | Page

input PageInput {
  content: PageContentBlockInput!
  seo: SeoBlockInput!
  stage: StageBlockInput!
}

type PageTreeNode {
  category: PageTreeNodeCategory!
  childNodes: [PageTreeNode!]!
  dependents(filter: DependentFilter, forceRefresh: Boolean! = false, limit: Int! = 25, offset: Int! = 0): PaginatedDependencies!
  document: PageContentUnion
  documentType: String!
  hideInMenu: Boolean!
  id: ID!
  name: String!
  numberOfDescendants: Int!
  parentId: String
  parentNode: PageTreeNode
  parentNodes: [PageTreeNode!]!
  path: String!
  pos: Int!
  scope: PageTreeNodeScope!
  slug: String!
  updatedAt: DateTime!
  visibility: PageTreeNodeVisibility!
}

enum PageTreeNodeCategory {
  mainNavigation
}

input PageTreeNodeCreateInput {
  attachedDocument: AttachedDocumentInput!
  hideInMenu: Boolean
  id: ID
  name: String!
  parentId: String
  pos: Int
  slug: String!
}

type PageTreeNodeScope {
  domain: String!
  language: String!
}

input PageTreeNodeScopeInput {
  domain: String!
  language: String!
}

input PageTreeNodeSort {
  direction: SortDirection! = ASC
  field: PageTreeNodeSortField!
}

enum PageTreeNodeSortField {
  pos
  updatedAt
}

input PageTreeNodeUpdateInput {
  attachedDocument: AttachedDocumentInput
  createAutomaticRedirectsOnSlugChange: Boolean = true
  hideInMenu: Boolean
  name: String!
  slug: String!
}

input PageTreeNodeUpdateVisibilityInput {
  visibility: PageTreeNodeVisibility!
}

enum PageTreeNodeVisibility {
  Archived
  Published
  Unpublished
}

type PaginatedDamFiles {
  nodes: [DamFile!]!
  totalCount: Int!
}

type PaginatedDamFolders {
  nodes: [DamFolder!]!
  totalCount: Int!
}

type PaginatedDamItems {
  nodes: [DamItem!]!
  totalCount: Int!
}

type PaginatedDamMediaAlternatives {
  nodes: [DamMediaAlternative!]!
  totalCount: Int!
}

type PaginatedDependencies {
  nodes: [Dependency!]!
  totalCount: Int!
}

type PaginatedPageTreeNodes {
  nodes: [PageTreeNode!]!
  totalCount: Int!
}

type PaginatedRedirects {
  nodes: [Redirect!]!
  totalCount: Int!
}

type PaginatedWarnings {
  nodes: [Warning!]!
  totalCount: Int!
}

enum Permission {
  builds
  cronJobs
  dam
  dependencies
  fileUploads
  impersonation
  pageTree
  prelogin
  translation
  userPermissions
  warnings
}

input PermissionFilter {
  equal: Permission
  isAnyOf: [Permission!]
  notEqual: Permission
}

type Query {
  blockPreviewJwt(includeInvisible: Boolean!, scope: JSONObject!, url: String!): String!
  currentUser: CurrentUser!
  damAreFilenamesOccupied(filenames: [FilenameInput!]!, scope: DamScopeInput! = {}): [FilenameResponse!]!
  damFile(id: ID!): DamFile!
  damFilesList(filter: FileFilterInput, folderId: ID, includeArchived: Boolean = false, limit: Int! = 25, offset: Int! = 0, scope: DamScopeInput! = {}, sortColumnName: String, sortDirection: SortDirection! = ASC): PaginatedDamFiles!
  damFolder(id: ID!): DamFolder!
  damFolderByNameAndParentId(name: String!, parentId: ID, scope: DamScopeInput! = {}): DamFolder
  damFoldersFlat(scope: DamScopeInput! = {}): [DamFolder!]!
  damFoldersList(filter: FolderFilterInput, includeArchived: Boolean, limit: Int! = 25, offset: Int! = 0, parentId: ID, scope: DamScopeInput! = {}, sortColumnName: String, sortDirection: SortDirection! = ASC): PaginatedDamFolders!
  damIsFilenameOccupied(filename: String!, folderId: String, scope: DamScopeInput! = {}): Boolean!
  damItemListPosition(filter: DamItemFilterInput, folderId: ID, id: ID!, includeArchived: Boolean, scope: DamScopeInput! = {}, sortColumnName: String, sortDirection: SortDirection! = ASC, type: DamItemType!): Int!
  damItemsList(filter: DamItemFilterInput, folderId: ID, includeArchived: Boolean, limit: Int! = 25, offset: Int! = 0, scope: DamScopeInput! = {}, sortColumnName: String, sortDirection: SortDirection! = ASC): PaginatedDamItems!
  damMediaAlternative(id: ID!): DamMediaAlternative!
  damMediaAlternatives(alternative: ID, for: ID, limit: Int! = 25, offset: Int! = 0, search: String, sort: [DamMediaAlternativeSort!], type: DamMediaAlternativeType): PaginatedDamMediaAlternatives!
  findCopiesOfFileInScope(id: ID!, imageCropArea: ImageCropAreaInput, scope: DamScopeInput! = {}): [DamFile!]!
  footer(scope: FooterScopeInput!): Footer
  link(id: ID!): Link
  mainMenu(scope: PageTreeNodeScopeInput!): [PageTreeNode!]!
  page(id: ID!): Page!
  pageTreeNode(id: ID!): PageTreeNode
  pageTreeNodeByPath(path: String!, scope: PageTreeNodeScopeInput!): PageTreeNode
  pageTreeNodeList(category: String, scope: PageTreeNodeScopeInput!): [PageTreeNode!]!
  pageTreeNodeSlugAvailable(parentId: ID, scope: PageTreeNodeScopeInput!, slug: String!): SlugAvailability!
  paginatedPageTreeNodes(category: String, documentType: String, limit: Int! = 25, offset: Int! = 0, scope: PageTreeNodeScopeInput!, sort: [PageTreeNodeSort!]): PaginatedPageTreeNodes!
  paginatedRedirects(filter: RedirectFilter, limit: Int! = 25, offset: Int! = 0, scope: RedirectScopeInput!, search: String, sort: [RedirectSort!]): PaginatedRedirects!
  redirect(id: ID!): Redirect!
  redirectBySource(scope: RedirectScopeInput!, source: String!, sourceType: RedirectSourceTypeValues!): Redirect
  redirectSourceAvailable(scope: RedirectScopeInput!, source: String!): Boolean!
  redirects(active: Boolean, query: String, scope: RedirectScopeInput!, sortColumnName: String, sortDirection: SortDirection! = ASC, type: RedirectGenerationType): [Redirect!]! @deprecated(reason: "Use paginatedRedirects instead. Will be removed in the next version.")
  sitePreviewJwt(includeInvisible: Boolean!, path: String!, scope: JSONObject!): String!
  userPermissionsAvailableContentScopes: [ContentScopeWithLabel!]!
  userPermissionsAvailablePermissions: [String!]!
  userPermissionsContentScopes(skipManual: Boolean, userId: String!): [JSONObject!]!
  userPermissionsPermission(id: ID!, userId: String): UserPermission!
  userPermissionsPermissionList(userId: String!): [UserPermission!]!
  userPermissionsUserById(id: String!): UserPermissionsUser!
  userPermissionsUsers(filter: UserPermissionsUserFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [UserPermissionsUserSort!]): UserPermissionPaginatedUserList!
  warning(id: ID!): Warning!
  warnings(filter: WarningFilter, limit: Int! = 25, offset: Int! = 0, scopes: [JSONObject!]!, search: String, sort: [WarningSort!], status: [WarningStatus!]! = [open]): PaginatedWarnings!
}

type Redirect {
  activatedAt: DateTime
  active: Boolean!
  comment: String
  createdAt: DateTime!
  dependencies(filter: DependencyFilter, forceRefresh: Boolean! = false, limit: Int! = 25, offset: Int! = 0): PaginatedDependencies!
  generationType: RedirectGenerationType!
  id: ID!
  scope: RedirectScope!
  source: String!
  sourceType: RedirectSourceTypeValues!
  target: JSONObject!
  updatedAt: DateTime!
}

input RedirectFilter {
  active: BooleanFilter
  and: [RedirectFilter!]
  createdAt: DateTimeFilter
  generationType: StringFilter
  or: [RedirectFilter!]
  source: StringFilter
  target: StringFilter
  updatedAt: DateTimeFilter
}

enum RedirectGenerationType {
  automatic
  manual
}

input RedirectInput {
  active: Boolean
  comment: String
  generationType: RedirectGenerationType!
  source: String!
  sourceType: RedirectSourceTypeValues!
  target: JSONObject!
}

type RedirectScope {
  domain: String!
}

input RedirectScopeInput {
  domain: String!
}

input RedirectSort {
  direction: SortDirection! = ASC
  field: RedirectSortField!
}

enum RedirectSortField {
  createdAt
  source
  updatedAt
}

enum RedirectSourceTypeValues {
  path
}

input RedirectUpdateActivenessInput {
  active: Boolean!
}

input ScopeFilter {
  equal: JSONObject
  isAnyOf: [JSONObject!]
  notEqual: JSONObject
}

"""Seo root block data"""
scalar SeoBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""Seo root block input"""
scalar SeoBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

enum SlugAvailability {
  Available
  Reserved
  Taken
}

enum SortDirection {
  ASC
  DESC
}

"""Stage root block data"""
scalar StageBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""Stage root block input"""
scalar StageBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input StringFilter {
  contains: String
  endsWith: String
  equal: String
  isAnyOf: [String!]
  isEmpty: Boolean
  isNotEmpty: Boolean
  notContains: String
  notEqual: String
  startsWith: String
}

input UpdateDamFileInput {
  altText: String
  folderId: ID
  image: UpdateImageFileInput
  license: LicenseInput
  name: String
  title: String
}

input UpdateDamFolderInput {
  archived: Boolean
  name: String
  parentId: ID
}

input UpdateImageFileInput {
  cropArea: ImageCropAreaInput
}

input UserContentScopesInput {
  contentScopes: [JSONObject!]! = []
}

type UserPermission {
  approvedBy: String
  contentScopes: [JSONObject!]!
  id: ID!
  overrideContentScopes: Boolean!
  permission: Permission!
  reason: String
  requestedBy: String
  source: UserPermissionSource!
  validFrom: DateTime
  validTo: DateTime
}

input UserPermissionInput {
  approvedBy: String
  permission: Permission!
  reason: String
  requestedBy: String
  validFrom: DateTime
  validTo: DateTime
}

input UserPermissionOverrideContentScopesInput {
  contentScopes: [JSONObject!]! = []
  overrideContentScopes: Boolean!
  permissionId: ID!
}

type UserPermissionPaginatedUserList {
  nodes: [UserPermissionsUser!]!
  totalCount: Int!
}

enum UserPermissionSource {
  BY_RULE
  MANUAL
}

type UserPermissionsUser {
  contentScopesCount: Int!
  email: String!
  id: String!
  impersonationAllowed: Boolean!
  name: String!
  permissionsCount: Int!
}

input UserPermissionsUserFilter {
  and: [UserPermissionsUserFilter!]
  email: StringFilter
  name: StringFilter
  or: [UserPermissionsUserFilter!]
  permission: PermissionFilter
  status: StringFilter
}

input UserPermissionsUserSort {
  direction: SortDirection! = ASC
  field: UserPermissionsUserSortField!
}

enum UserPermissionsUserSortField {
  email
  name
  status
}

type Warning {
  createdAt: DateTime!
  entityInfo: EntityInfo
  id: ID!
  message: String!
  scope: JSONObject
  severity: WarningSeverity!
  sourceInfo: WarningSourceInfo!
  status: WarningStatus!
  updatedAt: DateTime!
}

input WarningFilter {
  and: [WarningFilter!]
  createdAt: DateTimeFilter
  message: StringFilter
  or: [WarningFilter!]
  scope: ScopeFilter
  severity: WarningSeverityEnumFilter
  status: WarningStatusEnumFilter
  type: StringFilter
  updatedAt: DateTimeFilter
}

enum WarningSeverity {
  high
  low
  medium
}

input WarningSeverityEnumFilter {
  equal: WarningSeverity
  isAnyOf: [WarningSeverity!]
  notEqual: WarningSeverity
}

input WarningSort {
  direction: SortDirection! = ASC
  field: WarningSortField!
}

enum WarningSortField {
  createdAt
  message
  severity
  status
  type
  updatedAt
}

type WarningSourceInfo {
  jsonPath: String
  rootColumnName: String
  rootEntityName: String!
  rootPrimaryKey: String!
  targetId: String!
}

input WarningSourceInfoInput {
  jsonPath: String
  rootColumnName: String
  rootEntityName: String!
  rootPrimaryKey: String!
  targetId: String!
}

enum WarningStatus {
  ignored
  open
  resolved
}

input WarningStatusEnumFilter {
  equal: WarningStatus
  isAnyOf: [WarningStatus!]
  notEqual: WarningStatus
}